using UnityEngine;[RequireComponent(typeof(Camera))]public class OutlineFilter : MonoBehaviour{		[Header("Post Process")]	public Color m_Color = Color.green;	public bool m_Obstacle = false;	[Range(0.2f, 2.2f)] public float m_BlurPixelOffset = 1.2f;	[Range(1f, 6f)] public float m_GlowIntensity = 3f;		[Header("Internal")]	public Shader m_SdrGlowFlatColor;	public Shader m_SdrDepthOnly;	public Material m_MatGlowHalo;	public Material m_MatGlowBlur;	Camera m_Camera;	Camera m_RTCam;	OutlineMgr m_Mgr;	int m_ID_Offsets = 0;	int m_ID_GlowObjectTex = 0;	int m_ID_GlowColor = 0;	int m_ID_GlowIntensity = 0;		void Start ()	{		m_Mgr = GameObject.FindObjectOfType<OutlineMgr> ();		m_Camera = GetComponent<Camera> ();				// camera for post process outline		m_RTCam = new GameObject().AddComponent<Camera> ();		m_RTCam.name = "RTCam";		m_RTCam.transform.parent = m_Camera.gameObject.transform;        m_RTCam.enabled = false;				m_ID_Offsets = Shader.PropertyToID ("_Offsets");		m_ID_GlowObjectTex = Shader.PropertyToID ("_GlowObjectTex");		m_ID_GlowColor = Shader.PropertyToID ("_GlowColor");		m_ID_GlowIntensity = Shader.PropertyToID ("_GlowIntensity");	}	void OnEnable ()	{		m_SdrGlowFlatColor = Shader.Find ("Selected Effect --- Outline/Post Process/Flat Color");		m_SdrDepthOnly = Shader.Find ("Selected Effect --- Outline/Post Process/Depth Only");				Shader sdr = Shader.Find ("Selected Effect --- Outline/Post Process/Halo");		m_MatGlowHalo = new Material (sdr);				sdr = Shader.Find ("Selected Effect --- Outline/Post Process/Blur");		m_MatGlowBlur = new Material (sdr);	}	void OnDisable ()	{		if (m_MatGlowHalo)		{			DestroyImmediate (m_MatGlowHalo);			m_MatGlowHalo = null;		}		if (m_MatGlowBlur)		{			DestroyImmediate (m_MatGlowBlur);			m_MatGlowBlur = null;		}	}	void DoBlurPass (RenderTexture input, RenderTexture output, bool vertical)	{		if (vertical)		{			m_MatGlowBlur.SetVector (m_ID_Offsets, new Vector4 (0f, m_BlurPixelOffset, 0f, 0f));			Graphics.Blit (input, output, m_MatGlowBlur);		}		else		{			m_MatGlowBlur.SetVector (m_ID_Offsets, new Vector4 (m_BlurPixelOffset, 0f, 0f, 0f));			Graphics.Blit (input, output, m_MatGlowBlur);		}	}	void OnRenderImage (RenderTexture src, RenderTexture dst)    {		Graphics.Blit (src, dst);   // prepare main back framebuffer				m_RTCam.CopyFrom (m_Camera);		m_RTCam.clearFlags = CameraClearFlags.Color;		m_RTCam.backgroundColor = Color.black;   // r as mask, should be black here		RenderTexture tempRT = RenderTexture.GetTemporary (src.width, src.height, 16, RenderTextureFormat.R8);		m_RTCam.targetTexture = tempRT;				if (m_Obstacle)   // if obstacle enable, build depth buffer without glow object		{			m_RTCam.cullingMask = ~(1 << LayerMask.NameToLayer (m_Mgr.m_Layer));			m_RTCam.RenderWithShader (m_SdrDepthOnly, "");			m_RTCam.clearFlags = CameraClearFlags.Nothing;  // don't clear, keep depth buffer		}		m_RTCam.cullingMask = 1 << LayerMask.NameToLayer (m_Mgr.m_Layer);		m_RTCam.RenderWithShader (m_SdrGlowFlatColor, "");		// blur pass		int shrink = 1;  // shrink == 1 for best quality, try 2 or 4 for low quality but better performance		RenderTexture rt0 = RenderTexture.GetTemporary (Screen.width / shrink, Screen.height / shrink, 0);		RenderTexture rt1 = RenderTexture.GetTemporary (Screen.width / shrink, Screen.height / shrink, 0);		DoBlurPass (tempRT, rt0, true);		DoBlurPass (rt0, rt1, false);				// copy the temporary RT to the final image		m_MatGlowHalo.SetTexture (m_ID_GlowObjectTex, tempRT);		m_MatGlowHalo.SetColor (m_ID_GlowColor, m_Color);		m_MatGlowHalo.SetFloat (m_ID_GlowIntensity, m_GlowIntensity);		Graphics.Blit(rt1, dst, m_MatGlowHalo);		RenderTexture.ReleaseTemporary (tempRT);		RenderTexture.ReleaseTemporary (rt0);		RenderTexture.ReleaseTemporary (rt1);	}}